以下の観点で段階的に分割・整理すると、読みやすさと変更容易性が大きく改善します。

狙い

- 関心の分離: 幾何計算/状態/描画/UI を分離
- 再利用性: レール生成・ゴースト・保存/復元・カメラ/列車進行を composable に切り出し
- テンプレート縮小: 大きなテンプレートを子コンポーネントへ
- 型の一元化: discriminated union と Vec3 型で関数契約を厳密化
- マジックナンバーの排除: constants/utils へ集約

推奨構成（例）

- src/types
  - common.ts, rail.ts, game.ts
- src/utils
  - math.ts, id.ts
- src/composables
  - useRailsGeometry.ts（レール生成/ポーズ計算）
  - useGhostPreview.ts（ゴースト/配置回転/ポインタ追跡）
  - useTrainRunner.ts（列車進行/スムージング）
  - useCameraController.ts（カメラ追従/補間/モード切替）
  - useStorage.ts（保存/復元/メタ情報）
  - useKeyboardShortcuts.ts（R/E/Q など）
- src/components/panels
  - BuildPanel.vue, RunPanel.vue, CustomizePanel.vue, DebugPanel.vue, HelpDialog.vue
- src/components/scene
  - RailPlayScene.vue（TresCanvas と 3D 子要素を集約）
  - FloorGrid.vue, Walls.vue, RailsList.vue, GhostOverlays.vue, PiersList.vue など

効果的なリファクタリング案

- 幾何ロジック分離
  - makeStraight/makeSlope/makeLeftCurve/makeRightCurve、poseFromRailEnd、segmentLength、totalRailLength、getPoseOnRail を composable に移動
  - 角度補間/正規化、lerp/lerp3 は utils/math.ts に集約
- ゴーストと配置回転の分離
  - lastPointer, placementYaw, updateGhost, rotatePlacement, resetPlacementRotation を composable 化
  - ツール選択や rails.length の watch もそこへ
- 列車とカメラの分離
  - 列車のアニメーションループと carTransforms 更新を useTrainRunner へ
  - 先頭追従カメラの補間/モード切替を useCameraController へ
- ローカルストレージ分離
  - save/load/has/info、バージョン定数、通知メッセージを useStorage へ
  - UI 側はメソッドを呼ぶだけに
- UI 分割
  - サイドバーを BuildPanel/RunPanel/CustomizePanel/DebugPanel の4つに
  - ヘルプダイアログを HelpDialog.vue に
  - TresCanvas を RailPlayScene.vue に（クリックやポインタ移動を emit）
- 型の明確化
  - Rail を discriminated union に（type フィールドで分岐）
  - Vec3/Quat 型 alias、GameMode/CameraMode enum、Pose/CarPose などを types に抜き出し
- ID 生成をユーティリティへ
  - utils/id.ts に簡易 uid() を用意（Date.now() と Math.random の散在を回避）
- マジックナンバーの可視化
  - グリッドサイズ、角度ステップ、スムージング係数、しきい値を constants に集約
- 将来的な拡張
  - Pinia でゲーム全体の状態を集中管理（必要になったら）
  - Vitest で幾何関数の単体テスト

スケルトン（最小限の切り出し例）

1) 型とユーティリティ

````ts
export type Vec3 = [number, number, number];

export enum GameMode {
  Build = "build",
  Run = "run",
  Customize = "customize",
}
export enum CameraMode {
  Orbit = "orbit",
  Front = "front",
}
````

````ts
import type { Vec3 } from "./common";

export type RailBase = {
  id: string;
  position: Vec3;
  rotation: Vec3;
  connections: { start: Vec3; end: Vec3 };
};

export type StraightRail = RailBase & { type: "straight" };
export type SlopeRail = RailBase & { type: "slope" };
export type CurveRail = RailBase & { type: "curve"; direction: "left" | "right" };

export type Rail = StraightRail | SlopeRail | CurveRail;

export type Pose = { point: Vec3; theta: number };
export type CarPose = { position: Vec3; rotation: Vec3 };
````

````ts
export const lerp = (a: number, b: number, t: number) => a + (b - a) * t;
export const lerp3 = (a: [number, number, number], b: [number, number, number], t: number) => [
  lerp(a[0], b[0], t),
  lerp(a[1], b[1], t),
  lerp(a[2], b[2], t),
];

export const wrapAngle = (rad: number) => {
  while (rad > Math.PI) rad -= Math.PI * 2;
  while (rad < -Math.PI) rad += Math.PI * 2;
  return rad;
};

export const angleLerp = (current: number, target: number, t: number) => {
  const delta = wrapAngle(target - current);
  return current + delta * t;
};

export const snapTo = (value: number, step: number) => Math.round(value / step) * step;
````

2) レール生成と幾何

````ts
import { ref } from "vue";
import { CURVE_SEGMENT_ANGLE as CURVE_ANGLE, RAIL_CURVE_RADIUS, RAIL_STRAIGHT_FULL_LENGTH, RAIL_STRAIGHT_HALF_LENGTH, RAIL_SLOPE_RUN, RAIL_SLOPE_RISE } from "@/constants/rail";
import type { Rail, Pose, CarPose } from "@/types/rail";
import type { Vec3 } from "@/types/common";

export function useRailsGeometry() {
  const segmentLength = (r: Rail) =>
    r.type === "curve" ? RAIL_CURVE_RADIUS * CURVE_ANGLE
      : Math.hypot(r.connections.end[0] - r.connections.start[0], r.connections.end[2] - r.connections.start[2]);

  const makeStraight = (pose: Pose, length = RAIL_STRAIGHT_FULL_LENGTH): Rail => {
    const start = pose.point;
    const end: Vec3 = [
      start[0] + Math.cos(pose.theta) * length,
      start[1],
      start[2] + Math.sin(pose.theta) * length,
    ];
    const mid: Vec3 = [(start[0] + end[0]) / 2, start[1], (start[2] + end[2]) / 2];
    return {
      id: crypto.randomUUID?.() ?? `straight-${Date.now()}-${Math.random()}`,
      type: "straight",
      position: mid,
      rotation: [0, -pose.theta, 0],
      connections: { start, end },
    };
  };

  const makeSlope = (pose: Pose, ascending = true): Rail => {
    const start = pose.point;
    const dirx = Math.cos(pose.theta);
    const dirz = Math.sin(pose.theta);
    const rise = ascending ? RAIL_SLOPE_RISE : -RAIL_SLOPE_RISE;
    const end: Vec3 = [start[0] + dirx * RAIL_SLOPE_RUN, start[1] + rise, start[2] + dirz * RAIL_SLOPE_RUN];
    const mid: Vec3 = [(start[0] + end[0]) / 2, start[1], (start[2] + end[2]) / 2];
    return {
      id: crypto.randomUUID?.() ?? `slope-${Date.now()}-${Math.random()}`,
      type: "slope",
      position: mid,
      rotation: [0, -pose.theta, 0],
      connections: { start, end },
    };
  };

  const makeLeftCurve = (pose: Pose): Rail => {
    const r = RAIL_CURVE_RADIUS;
    const cx = pose.point[0] - Math.sin(pose.theta) * r;
    const cz = pose.point[2] + Math.cos(pose.theta) * r;
    const end: Vec3 = [
      cx + Math.sin(pose.theta + CURVE_ANGLE) * r,
      0,
      cz - Math.cos(pose.theta + CURVE_ANGLE) * r,
    ];
    return {
      id: crypto.randomUUID?.() ?? `curve-left-${Date.now()}-${Math.random()}`,
      type: "curve",
      position: [cx, 0, cz],
      rotation: [0, pose.theta, 0],
      connections: { start: pose.point, end },
      direction: "left",
    };
  };

  const makeRightCurve = (pose: Pose): Rail => {
    const r = RAIL_CURVE_RADIUS;
    const cx = pose.point[0] + Math.sin(pose.theta) * r;
    const cz = pose.point[2] - Math.cos(pose.theta) * r;
    const end: Vec3 = [
      cx - Math.sin(pose.theta - CURVE_ANGLE) * r,
      0,
      cz + Math.cos(pose.theta - CURVE_ANGLE) * r,
    ];
    return {
      id: crypto.randomUUID?.() ?? `curve-right-${Date.now()}-${Math.random()}`,
      type: "curve",
      position: [cx, 0, cz],
      rotation: [0, pose.theta, 0],
      connections: { start: pose.point, end },
      direction: "right",
    };
  };

  const poseFromRailEnd = (rail: Rail): Pose => {
    const end = rail.connections.end;
    if (rail.type === "curve") {
      const base = rail.rotation[1];
      const theta = rail.direction === "right" ? base - CURVE_ANGLE : base + CURVE_ANGLE;
      return { point: end, theta };
    }
    return { point: end, theta: -rail.rotation[1] };
  };

  return {
    segmentLength,
    makeStraight,
    makeSlope,
    makeLeftCurve,
    makeRightCurve,
    poseFromRailEnd,
    RAIL_STRAIGHT_HALF_LENGTH,
    RAIL_SLOPE_RUN,
  };
}
````

3) ストレージ

````ts
import { ref } from "vue";
import type { Rail } from "@/types/rail";
import type { GameMode } from "@/types/common";

type SaveData = {
  version: string;
  timestamp: number;
  rails: Rail[];
  trees: Array<{ position: [number, number, number]; rotation?: [number, number, number] }>;
  buildings: Array<{ position: [number, number, number]; height?: number; color?: string; rotation?: [number, number, number] }>;
  piers: Array<{ position: [number, number, number]; height?: number; rotation?: [number, number, number] }>;
  gameMode: GameMode;
  isRailsLocked: boolean;
};

const SAVE_KEY = "rail-play-game-data";
const SAVE_VERSION = "1.0.0";

export function useStorage() {
  const info = ref<null | { timestamp: number; version: string; railsCount: number; treesCount: number; buildingsCount: number; piersCount: number }>(null);

  const save = (payload: Omit<SaveData, "version" | "timestamp">) => {
    const total = payload.rails.length + payload.trees.length + payload.buildings.length + payload.piers.length;
    if (total === 0) return { ok: false, message: "保存するデータがありません" };
    const data: SaveData = { ...payload, version: SAVE_VERSION, timestamp: Date.now() };
    localStorage.setItem(SAVE_KEY, JSON.stringify(data));
    info.value = {
      timestamp: data.timestamp,
      version: data.version,
      railsCount: data.rails.length,
      treesCount: data.trees.length,
      buildingsCount: data.buildings.length,
      piersCount: data.piers.length,
    };
    return { ok: true, message: "ゲームデータを保存しました", data };
  };

  const load = () => {
    const str = localStorage.getItem(SAVE_KEY);
    if (!str) return { ok: false, message: "保存データが見つかりません" };
    const data: SaveData = JSON.parse(str);
    info.value = {
      timestamp: data.timestamp,
      version: data.version,
      railsCount: data.rails?.length || 0,
      treesCount: data.trees?.length || 0,
      buildingsCount: data.buildings?.length || 0,
      piersCount: data.piers?.length || 0,
    };
    return { ok: true, message: "ゲームデータを復元しました", data };
  };

  const has = () => localStorage.getItem(SAVE_KEY) !== null;

  return { info, save, load, has, SAVE_VERSION };
}
````

4) ヘルプダイアログを子コンポーネントへ

````vue
<template>
  <v-dialog v-model="model" max-width="800px">
    <v-card>
      <v-card-title class="text-h5">
        <v-icon class="mr-2">mdi-help-circle</v-icon>
        遊び方ガイド
      </v-card-title>
      <v-card-text>
        <slot />
      </v-card-text>
      <v-card-actions>
        <v-spacer />
        <v-btn color="primary" text @click="model = false">閉じる</v-btn>
      </v-card-actions>
    </v-card>
  </v-dialog>
</template>

<script setup lang="ts">
const model = defineModel<boolean>({ required: true });
</script>
````

RailPlayGame.vue の置き換えイメージ（テンプレートの大幅縮小）

- 左サイドバーは BuildPanel/RunPanel/CustomizePanel/DebugPanel の切替だけに
- TresCanvas 以下は RailPlayScene へ集約
- 保存/復元は useStorage でハンドル

段階的移行手順（小さな PR を複数に分割）

1) types と utils を作成し、Rail 型と math 関数を移動（既存コードから import 差し替え）
2) useRailsGeometry を導入し、makeXxx/poseFromRailEnd/segmentLength を移動
3) useStorage を導入し、保存/復元ロジックを置換（UI 通知は既存の snackbar を再利用）
4) HelpDialog.vue を作成し、テンプレートから抜き出し
5) RailPlayScene.vue を作成し、TresCanvas と 3D 要素を移動（クリック/ポインタイベントは emit）
6) useTrainRunner と useCameraController に列車/カメラを分離（アニメループもここへ）
7) useGhostPreview へゴーストと配置回転、キーボードを useKeyboardShortcuts でハンドル
8) サイドバーを BuildPanel/RunPanel/CustomizePanel/DebugPanel に分解

テスト観点

- 幾何: makeStraight/Curve/Slope の start/end、poseFromRailEnd の角度、segmentLength の値
- 列車: 直線/曲線/スロープ上での getPoseOnRail の yaw/pitch 一貫性
- 保存/復元: バージョンが異なる時の後方互換、空データ

この方針なら、表示とロジックが明確に分離され、今後の機能追加（ポイント分岐、レール種類追加、UI 切替）も局所的な変更で済みます。必要なら、次のステップとして Pinia にゲーム状態を集約する提案もできます。
